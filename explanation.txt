# WebSocket Heartbeat Mechanism Changes

## Problem
We needed to add a robust heartbeat mechanism to our WebSocket consumers to ensure connections remain active and to detect stale connections. This helps prevent resource leaks and ensures users receive real-time updates reliably.

## Solution Summary
We implemented a heartbeat mechanism in both the ChatConsumer and NotificationConsumer classes that:
1. Periodically sends heartbeat messages to clients
2. Monitors client responses to detect stale connections
3. Automatically closes connections that haven't responded for too long
4. Handles reconnection gracefully

## Changes Made:

1. Added heartbeat tracking properties to consumers:
   - Added `last_ping` to track when the last heartbeat response was received
   - Added `heartbeat_interval` to set the frequency of heartbeat checks
   - Added `heartbeat_task` to store the asyncio task that runs the heartbeat

2. Added an asyncio task that:
   - Runs periodically based on the configured interval
   - Sends heartbeat messages to clients
   - Monitors for stale connections
   - Closes stale connections with appropriate close codes

3. Added client message handling for:
   - Ping/pong messages to maintain the connection
   - Reconnection messages to handle clients that temporarily disconnect

4. Added proper cleanup:
   - Cancel heartbeat tasks during disconnection
   - Clear all resources when connections close

5. Added detailed logging:
   - Track connection establishment/closure
   - Log stale connection detection
   - Record reconnection events

## Key Code Patterns:

```python
# Initialize heartbeat tracking
self.last_ping = timezone.now()
self.heartbeat_interval = getattr(settings, "WEBSOCKET_HEARTBEAT_INTERVAL", 30)
self.heartbeat_task = None

# Start heartbeat monitoring
self.heartbeat_task = asyncio.create_task(self.send_heartbeat())

# The heartbeat monitoring function
async def send_heartbeat(self):
    try:
        while True:
            await asyncio.sleep(self.heartbeat_interval)
            
            # Check if connection is stale
            time_since_last_ping = (timezone.now() - self.last_ping).total_seconds()
            if time_since_last_ping > self.heartbeat_interval * 3:
                logger.warning(f"Connection stale, closing")
                await self.close(code=4000)
                break
                
            # Send heartbeat
            await self.send_json({'type': 'heartbeat'})
    except asyncio.CancelledError:
        # Normal cancellation during disconnect
        pass
    except Exception as e:
        logger.error(f"Error in heartbeat task: {str(e)}")
        await self.close(code=4001)
```

## Benefits of the Change
1. Improved reliability of WebSocket connections
2. Automatic detection and cleanup of stale connections
3. Reduced server resource waste from zombie connections
4. Better user experience with automatic reconnection
5. Detailed logging for monitoring connection health

## Configuration Options
The heartbeat mechanism is configurable via settings:
- WEBSOCKET_HEARTBEAT_INTERVAL: Time between heartbeat messages (default: 30 seconds)
- For high-traffic applications, you might want to increase this value to reduce overhead
